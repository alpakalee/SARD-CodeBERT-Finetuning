[
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67_structType myStruct;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45_badData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_67_structType myStruct;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    data = NULL;\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_61a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_61a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_61b_goodG2BSource(data);\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_16_good1",
        "code": "static void good1()\n{\n    while(1)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n        break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_34_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_34_unionType myUnion;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myUnion.unionFirst = data;\n    {\n        twoIntsStruct * data = myUnion.unionSecond;\n        {\n            twoIntsStruct source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(twoIntsStruct));\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_51a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_51b_goodB2GSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_14_good1",
        "code": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    int64_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45_badData;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            wcscpy(data, source);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    void * data;\n    data = NULL;\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set data to point to a char string */\n        data = (void *)CHAR_STRING;\n    }\n    if(staticTrue)\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * 1);\n            (void)strcpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_44.c",
        "function_name": "badSink",
        "code": "static void badSink(int64_t * data)\n{\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_45_badData;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_16_good1",
        "code": "static void good1()\n{\n    while(1)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n        break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_01_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_44.c",
        "function_name": "badSink",
        "code": "static void badSink(char * data)\n{\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_11_good1",
        "code": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_45_badData;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_44_goodG2BSink",
        "code": "static void goodG2BSink(char * data)\n{\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_44_goodG2BSink",
        "code": "static void goodG2BSink(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char dest[50] = \"\";\n            size_t i, dataLen;\n            dataLen = strlen(data);\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            for (i = 0; i < dataLen; i++)\n            {\n                dest[i] = data[i];\n            }\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    void (*funcPtr) (twoIntsStruct *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_65b_goodG2BSink;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45_badData;\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            strcpy(dest, data);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(staticFive==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    {\n        char * data = *dataPtr1;\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strncpy(data, source, strlen(source) + 1);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_34_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_34_unionType myUnion;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memmove(dest, data, strlen(data)*sizeof(char));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_18_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(staticFive==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_16_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    data = NULL;\n    while(1)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n        break;\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_21_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    goodG2B2Static = 1; /* true */\n    data = goodG2B2Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_02_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_goodB2GData = data;\n    goodB2GSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    goto source;\nsource:\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22a_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22_goodG2B2Global = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22_goodG2B2Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67_structType myStruct;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_44.c",
        "function_name": "badSink",
        "code": "static void badSink(twoIntsStruct * data)\n{\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_21_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    goodG2B2Static = 1; /* true */\n    data = goodG2B2Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = goodG2BSink;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_45_badData;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_45_goodG2BData;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45_badData;\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    goodG2B2Static = 1; /* true */\n    data = goodG2B2Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_32_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    int *dataPtr1 = &data;\n    int *dataPtr2 = &data;\n    /* Initialize data */\n    data = -1;\n    {\n        int data = *dataPtr1;\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n        *dataPtr1 = data;\n    }\n    {\n        int data = *dataPtr2;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_44.c",
        "function_name": "badSink",
        "code": "static void badSink(int * data)\n{\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_22a_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_22_goodG2B1Global = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_22_goodG2B1Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            SNPRINTF(data, 100, \"%s\", source);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67_structType myStruct;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_18_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_18_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_45_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(globalTrue)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_44_goodG2BSink",
        "code": "static void goodG2BSink(int * data)\n{\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_12_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_67_structType myStruct;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, wcslen(data), L\"%s\", data);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            wcscat(data, source);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45_goodG2BData;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_44.c",
        "function_name": "badSink",
        "code": "static void badSink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_12_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_61a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_61a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_61b_goodG2BSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_12_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_44.c",
        "function_name": "badSink",
        "code": "static void badSink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_45_badData;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_01_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_44.c",
        "function_name": "badSink",
        "code": "static void badSink(char * data)\n{\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            strncpy(dest, data, strlen(data));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_12_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n    }\n    else\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_65b_goodG2BSink;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_01_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_16_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    while(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_45_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_44_goodG2BSink",
        "code": "static void goodG2BSink(char * data)\n{\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_44_goodG2BSink",
        "code": "static void goodG2BSink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n            wcsncat(dest, data, wcslen(data));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_12_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataArray[5];\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_45_goodG2BData;\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    void (*funcPtr) (int64_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_65b_goodG2BSink;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65b_goodG2BSink;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_10_goodB2G2",
        "code": "static void goodB2G2()\n{\n    void * data;\n    data = NULL;\n    if(globalTrue)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(globalTrue)\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_03_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(5==5)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_01_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_18_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_44.c",
        "function_name": "badSink",
        "code": "static void badSink(void * data)\n{\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printLine((char *)dest);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_42.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_42_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    data = goodG2BSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_05_good1",
        "code": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45_goodG2BData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_65b_goodG2BSink;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_45_badData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = wcslen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_31_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    {\n        int * dataCopy = data;\n        int * data = dataCopy;\n        {\n            int source[10] = {0};\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            for (i = 0; i < 10; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_44_goodG2BSink",
        "code": "static void goodG2BSink(int * data)\n{\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_10_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalTrue)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticFive==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(staticFive==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_14_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_45_goodB2GSink",
        "code": "static void goodB2GSink()\n{\n    void * data = CWE121_Stack_Based_Buffer_Overflow__CWE135_45_goodB2GData;\n    {\n        /* FIX: treating pointer like a wchar_t*  */\n        size_t dataLen = wcslen((wchar_t *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printWLine((wchar_t *)dest);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_45_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_67_structType myStruct;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_16_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    while(1)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n        break;\n    }\n    while(1)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n        break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    data = NULL;\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(globalTrue)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_34_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_34_unionType myUnion;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = wcslen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, strlen(data)*sizeof(char));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    data = NULL;\n    if(globalReturnsTrue())\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_12_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_31_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        int dataCopy = data;\n        int data = dataCopy;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h,j;\n    int data;\n    /* Initialize data */\n    data = -1;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    int64_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45_badData;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_06_goodB2G2",
        "code": "static void goodB2G2()\n{\n    void * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_04_good2",
        "code": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticReturnsTrue())\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67b_goodB2GSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_10_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalTrue)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            SNPRINTF(data, 100, L\"%s\", source);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_16_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_22a_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_22_goodB2G2Global = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_22_goodB2G2Sink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_16_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    while(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = goodG2BSink;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_12_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    else\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_67_structType myStruct;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_41_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_18_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_44_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    void (*funcPtr) (int) = goodG2BSink;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_08_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticReturnsTrue())\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45_badData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_67_structType myStruct;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22a_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22_goodG2B1Global = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22_goodG2B1Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21_goodB2G1Sink",
        "code": "static void goodB2G1Sink(int data)\n{\n    if(goodB2G1Static)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = goodG2BSink;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_34_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_34_unionType myUnion;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_10_good2",
        "code": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_05_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticTrue)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_22a_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_22_goodG2B1Global = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_22_goodG2B1Source(data);\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    {\n        char * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            strncat(data, source, 100);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34_unionType myUnion;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printLongLongLine(data[0]);\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45_goodG2BData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_44_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    void (*funcPtr) (int) = goodG2BSink;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            strcat(data, source);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    void (*funcPtr) (int64_t *) = goodG2BSink;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_21_goodG2B",
        "code": "static void goodG2B()\n{\n    void * data;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    goodG2BStatic = 1; /* true */\n    goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_31_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int64_t * dataCopy = data;\n        int64_t * data = dataCopy;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printLongLongLine(data[0]);\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_45_badData;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_45_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_04_good1",
        "code": "static void good1()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    void (*funcPtr) (int) = goodB2GSink;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_15_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    {\n        char * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            strncpy(data, source, 100-1);\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_14_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Use an invalid index */\n        data = 10;\n    }\n    if(globalFive==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_05_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticTrue)\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n    }\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_34_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_34_unionType myUnion;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    myUnion.unionFirst = data;\n    {\n        int data = myUnion.unionSecond;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_01_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_22a_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_22_goodG2B1Global = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_22_goodG2B1Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_45_badData;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    goodG2B2Static = 1; /* true */\n    data = goodG2B2Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67_structType myStruct;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34_unionType myUnion;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myUnion.unionFirst = data;\n    {\n        twoIntsStruct * data = myUnion.unionSecond;\n        {\n            twoIntsStruct source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printStructLine(&data[0]);\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45_badData;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_45_goodG2B",
        "code": "static void goodG2B()\n{\n    void * data;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_65b_goodG2BSink;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_34_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_34_unionType myUnion;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, wcslen(data), L\"%s\", data);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    data = NULL;\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_12_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_12_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_45_badData;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_12_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_09_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Use an invalid index */\n        data = 10;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_32_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t * *dataPtr1 = &data;\n    int64_t * *dataPtr2 = &data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    {\n        int64_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        *dataPtr1 = data;\n    }\n    {\n        int64_t * data = *dataPtr2;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printLongLongLine(data[0]);\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_67_structType myStruct;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_13_good1",
        "code": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_17_goodB2G",
        "code": "static void goodB2G()\n{\n    int i,k;\n    int data;\n    /* Initialize data */\n    data = -1;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    for(k = 0; k < 1; k++)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_45_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_44.c",
        "function_name": "badSink",
        "code": "static void badSink(char * data)\n{\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_05_goodB2G1",
        "code": "static void goodB2G1()\n{\n    void * data;\n    data = NULL;\n    if(staticTrue)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54b_goodB2GSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_18_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    goto source;\nsource:\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    goto sink;\nsink:\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = goodG2BSink;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_15_good2",
        "code": "static void good2()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printLine((char *)structCharVoid.voidSecond);\n        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n        printLine((char *)structCharVoid.charFirst);\n        printLine((char *)structCharVoid.voidSecond);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_22a_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_22_goodG2B1Global = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_22_goodG2B1Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalFive==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(globalFive==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45_goodG2BData;\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_65b_goodG2BSink;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_45_goodG2BData;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_45_badData;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_15_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    switch(6)\n    {\n    case 6:\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n    break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_61a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_61a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_61b_goodG2BSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_12_good1",
        "code": "static void good1()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_22a_goodB2G1",
        "code": "static void goodB2G1()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_22_goodB2G1Global = 0; /* false */\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_22_goodB2G1Sink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_13_goodB2G1",
        "code": "static void goodB2G1()\n{\n    void * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_01_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45_badData;\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_41_goodB2GSink",
        "code": "static void goodB2GSink(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticTrue)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(staticTrue)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_44.c",
        "function_name": "badSink",
        "code": "static void badSink(char * data)\n{\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_21_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    goodG2B2Static = 1; /* true */\n    data = goodG2B2Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_01_goodG2B",
        "code": "static void goodG2B()\n{\n    void * data;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * 1);\n        (void)strcpy(dest, data);\n        printLine((char *)dest);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    int data = CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_45_goodG2BData;\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            wcsncat(data, source, 100);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_17_goodB2G",
        "code": "static void goodB2G()\n{\n    int i,k;\n    int data;\n    /* Initialize data */\n    data = -1;\n    for(i = 0; i < 1; i++)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    for(k = 0; k < 1; k++)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    goto source;\nsource:\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(1)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_09_good2",
        "code": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    void * data;\n    data = NULL;\n    if(staticFive==5)\n    {\n        /* FIX: Set data to point to a char string */\n        data = (void *)CHAR_STRING;\n    }\n    if(staticFive==5)\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * 1);\n            (void)strcpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_67_structType myStruct;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_61a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_61a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_61b_goodG2BSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_05_good1",
        "code": "static void good1()\n{\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_18_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    data = NULL;\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n            wcscat(dest, data);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54b_goodB2GSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_01_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcsncpy(data, source, wcslen(source) + 1);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_67_structType myStruct;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_68a_goodB2G",
        "code": "static void goodB2G()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_68_goodB2GData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_68b_goodB2GSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_21.c",
        "function_name": "badSink",
        "code": "static void badSink(int data)\n{\n    if(badStatic)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_03_good1",
        "code": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_18_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_02_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, strlen(data), \"%s\", data);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_07_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_61a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_61a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_61b_goodG2BSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_01_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_31_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    {\n        int dataCopy = data;\n        int data = dataCopy;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_01_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_41_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_01_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_12_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_17_good1",
        "code": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_42.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_42_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    data = goodG2BSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_16_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_05_good2",
        "code": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_13_good1",
        "code": "static void good1()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_44_goodG2BSink",
        "code": "static void goodG2BSink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_65b_goodG2BSink;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_45_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_16_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_12_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_12_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_67_structType myStruct;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_65b_goodG2BSink;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_65b_goodG2BSink;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_41.c",
        "function_name": "badSink",
        "code": "static void badSink(void * data)\n{\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printLine((char *)dest);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_65b_goodG2BSink;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61b_goodG2BSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, strlen(data)*sizeof(char));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            SNPRINTF(data, 100, \"%s\", source);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_09_good1",
        "code": "static void good1()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            SNPRINTF(data, 100, L\"%s\", source);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memcpy(data, source, 100*sizeof(wchar_t));\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_12_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64b_goodB2GSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_22a_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_22_goodG2B2Global = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_22_goodG2B2Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = wcslen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_67_structType myStruct;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_44_goodG2BSink",
        "code": "static void goodG2BSink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53b_goodB2GSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_16_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    data = NULL;\n    while(1)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n        break;\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_44.c",
        "function_name": "badSink",
        "code": "static void badSink(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcscpy(data, source);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_16_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    while(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45_badData;\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    void * data;\n    data = NULL;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set data to point to a char string */\n        data = (void *)CHAR_STRING;\n    }\n    if(globalFive==5)\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * 1);\n            (void)strcpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_11_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n    }\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    data = NULL;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_03_goodB2G2",
        "code": "static void goodB2G2()\n{\n    void * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(5==5)\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = goodG2BSink;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n        break;\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_34_goodB2G",
        "code": "static void goodB2G()\n{\n    void * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_34_unionType myUnion;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    myUnion.unionFirst = data;\n    {\n        void * data = myUnion.unionSecond;\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45_goodB2GSink",
        "code": "static void goodB2GSink()\n{\n    int data = CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45_goodB2GData;\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_65a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_65b_goodB2GSink;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataArray[5];\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_65b_goodG2BSink;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_52a_goodB2G",
        "code": "static void goodB2G()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_52b_goodB2GSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_12_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41.c",
        "function_name": "badSink",
        "code": "static void badSink(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_16_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45_goodB2GSink",
        "code": "static void goodB2GSink()\n{\n    int data = CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45_goodB2GData;\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, wcslen(data), L\"%s\", data);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_16_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_12_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44.c",
        "function_name": "badSink",
        "code": "static void badSink(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memcpy(data, source, 100*sizeof(wchar_t));\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_41_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_34_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_34_unionType myUnion;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcsncpy(data, source, wcslen(source) + 1);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    void * data;\n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set data to point to a char string */\n        data = (void *)CHAR_STRING;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * 1);\n            (void)strcpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_66a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_66b_goodB2GSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_01_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_31_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        twoIntsStruct * dataCopy = data;\n        twoIntsStruct * data = dataCopy;\n        {\n            twoIntsStruct source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(twoIntsStruct));\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_67_structType myStruct;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_12_goodB2G",
        "code": "static void goodB2G()\n{\n    void * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    else\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n    else\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_44.c",
        "function_name": "badSink",
        "code": "static void badSink(int * data)\n{\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_12_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_45_badData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    {\n        char * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            size_t i;\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67_structType myStruct;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_45_badData;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    goodB2G2Static = 1; /* true */\n    goodB2G2Sink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_18_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_16_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_61a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_61a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_61b_goodG2BSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_53a_goodB2G",
        "code": "static void goodB2G()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_53b_goodB2GSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            wcscpy(dest, data);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    goodG2B1Static = 0; /* false */\n    data = goodG2B1Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67_structType myStruct;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_44_goodB2GSink",
        "code": "static void goodB2GSink(void * data)\n{\n    {\n        /* FIX: treating pointer like a wchar_t*  */\n        size_t dataLen = wcslen((wchar_t *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printWLine((wchar_t *)dest);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_45_badData;\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_64a_goodB2G",
        "code": "static void goodB2G()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_64b_goodB2GSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_44_goodG2BSink",
        "code": "static void goodG2BSink(char * data)\n{\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_34_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_34_unionType myUnion;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcscpy(data, source);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n            wcsncat(dest, data, wcslen(data));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_16_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    while(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = strlen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    void (*funcPtr) (int) = goodG2BSink;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_18_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_08_good1",
        "code": "static void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_06_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_12_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_44_goodG2BSink",
        "code": "static void goodG2BSink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_67_structType myStruct;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(5==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_05_good2",
        "code": "static void good2()\n{\n    if(staticTrue)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            strcpy(dest, data);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_07_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_45_badData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_44_goodG2BSink",
        "code": "static void goodG2BSink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_63a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_63b_goodB2GSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_41_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_45_badData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memmove(data, source, (strlen(source) + 1) * sizeof(char));\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_44_goodG2BSink",
        "code": "static void goodG2BSink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_41_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22_goodG2BGlobal = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_01_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53b_goodB2GSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            strncpy(data, source, 100-1);\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_34_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_34_unionType myUnion;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = strlen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_12_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34_unionType myUnion;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_44_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = goodG2BSink;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_12_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    void * data;\n    data = NULL;\n    if(staticTrue)\n    {\n        /* FIX: Set data to point to a char string */\n        data = (void *)CHAR_STRING;\n    }\n    if(staticTrue)\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * 1);\n            (void)strcpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34_unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[10] = {0};\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            memcpy(data, source, 10*sizeof(int));\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_45_badData;\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_16_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67_structType myStruct;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcsncpy(data, source, wcslen(source) + 1);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_65b_goodG2BSink;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67_structType myStruct;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_44_goodG2BSink",
        "code": "static void goodG2BSink(char * data)\n{\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_12_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_03_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_45_goodG2BData;\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_44_goodG2BSink",
        "code": "static void goodG2BSink(int64_t * data)\n{\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_10_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalTrue)\n    {\n        /* POTENTIAL FLAW: Use an invalid index */\n        data = 10;\n    }\n    if(globalTrue)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_44_goodG2BSink",
        "code": "static void goodG2BSink(int * data)\n{\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45_goodG2BData;\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticTrue)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(staticTrue)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_06_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Use an invalid index */\n        data = 10;\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_10_good2",
        "code": "static void good2()\n{\n    if(globalTrue)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_45_goodG2BData;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    data = NULL;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_44_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = goodG2BSink;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_67_structType myStruct;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_64a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_64b_goodB2GSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrue())\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22a_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22_goodB2G2Global = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22_goodB2G2Sink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    void (*funcPtr) (int *) = goodG2BSink;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67_structType myStruct;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_44_goodG2BSink",
        "code": "static void goodG2BSink(twoIntsStruct * data)\n{\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_41_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_34_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_34_unionType myUnion;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memmove(data, source, 100*sizeof(wchar_t));\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_44_goodG2BSink",
        "code": "static void goodG2BSink(wchar_t * data)\n{\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_06_good1",
        "code": "static void good1()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_44_goodG2BSink",
        "code": "static void goodG2BSink(char * data)\n{\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            strcat(data, source);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_11_good1",
        "code": "static void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    goodG2B1Static = 0; /* false */\n    data = goodG2B1Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_18_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    {\n        char * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memcpy(data, source, 100*sizeof(char));\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_17_goodB2G",
        "code": "static void goodB2G()\n{\n    int i,k;\n    int data;\n    /* Initialize data */\n    data = -1;\n    for(i = 0; i < 1; i++)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    for(k = 0; k < 1; k++)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_16_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_44_goodG2BSink",
        "code": "static void goodG2BSink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_03_good1",
        "code": "static void good1()\n{\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_22a_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_22_goodG2B2Global = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_22_goodG2B2Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_16_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_15_good1",
        "code": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printLine((char *)structCharVoid.voidSecond);\n        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n        printLine((char *)structCharVoid.charFirst);\n        printLine((char *)structCharVoid.voidSecond);\n    }\n    break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_14_good1",
        "code": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45_goodG2BData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    {\n        char * data = *dataPtr1;\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = strlen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            wcscat(data, source);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_45_goodG2BData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_16_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_01_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_13_good2",
        "code": "static void good2()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, strlen(data), \"%s\", data);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_11_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrue())\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strcpy(data, source);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_04_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_09_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_45_badData;\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_16_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_16_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_41_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalFive==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(globalFive==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45_goodG2BData;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_44_goodG2BSink",
        "code": "static void goodG2BSink(twoIntsStruct * data)\n{\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_07_good1",
        "code": "static void good1()\n{\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_05_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticTrue)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    int data = CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45_badData;\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_07_good2",
        "code": "static void good2()\n{\n    if(staticFive==5)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_01_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_42.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_42_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    data = goodG2BSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_65b_goodG2BSink;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_21_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    goodG2B2Static = 1; /* true */\n    data = goodG2B2Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_45_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_45_badData;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45_badData;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22a_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B2Global = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B2Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_04_good2",
        "code": "static void good2()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataArray[5];\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_65b_goodG2BSink;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    void (*funcPtr) (twoIntsStruct *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65b_goodG2BSink;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_44_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = goodG2BSink;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_21_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    goodG2B2Static = 1; /* true */\n    data = goodG2B2Source(data);\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataArray[5];\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(1)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(1)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_16_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_07_goodB2G2",
        "code": "static void goodB2G2()\n{\n    void * data;\n    data = NULL;\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(staticFive==5)\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41_goodB2GSink",
        "code": "static void goodB2GSink(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            size_t i;\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_42.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_42_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    data = goodG2BSource(data);\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_15_good1",
        "code": "static void good1()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printWLine((wchar_t *)structCharVoid.voidSecond);\n        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n        printWLine((wchar_t *)structCharVoid.charFirst);\n        printWLine((wchar_t *)structCharVoid.voidSecond);\n    }\n    break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    {\n        char * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            strcpy(data, source);\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_06_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_45_badData;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_63b_goodG2BSink(&data);\n}",
        "target": 0
    }
]