[
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_45_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_01_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21.c",
        "function_name": "badSink",
        "code": "static void badSink(int data)\n{\n    if(badStatic)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_41_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_02_good2",
        "code": "static void good2()\n{\n    if(1)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_21_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    goodG2B2Static = 1; /* true */\n    data = goodG2B2Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_44_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    void (*funcPtr) (twoIntsStruct *) = goodG2BSink;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_18_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t dest[50] = L\"\";\n            size_t i, dataLen;\n            dataLen = wcslen(data);\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            for (i = 0; i < dataLen; i++)\n            {\n                dest[i] = data[i];\n            }\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_61a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_61a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_61b_goodG2BSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_09_good2",
        "code": "static void good2()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_09_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_44.c",
        "function_name": "badSink",
        "code": "static void badSink(int * data)\n{\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_45_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t * dataArray[5];\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_11_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Use an invalid index */\n        data = 10;\n    }\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_17_good1",
        "code": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_34_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_34_unionType myUnion;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_31_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memmove(data, source, 100*sizeof(char));\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_67_structType myStruct;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_16_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_45_badData;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_22a_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_22_goodG2B1Global = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_22_goodG2B1Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_65a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_large_65b_goodB2GSink;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    data = NULL;\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_44.c",
        "function_name": "badSink",
        "code": "static void badSink(char * data)\n{\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_32.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_32_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            wcsncpy(data, source, 100-1);\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_51a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_51a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_51b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    goodB2G1Static = 0; /* false */\n    goodB2G1Sink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_02_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_31.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_31_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcscpy(data, source);\n            printWLine(data);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_45_badData;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_10_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalTrue)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(globalTrue)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68a_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68_goodB2GData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68b_goodB2GSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataArray[5];\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_08_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_14_good1",
        "code": "static void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_16_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_44_goodG2BSink",
        "code": "static void goodG2BSink(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_41_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_22a_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_22_goodG2B2Global = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_22_goodG2B2Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_03_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(5==5)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    if(5==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_17_good1",
        "code": "static void good1()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_01_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_04_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_22a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_22a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_22_goodG2BGlobal = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_22_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_65a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_65a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_65b_goodG2BSink;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_large_02_goodB2G2",
        "code": "static void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(1)\n    {\n        /* POTENTIAL FLAW: Use an invalid index */\n        data = 10;\n    }\n    if(1)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_68a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_68a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_68_goodG2BData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_68b_goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_45_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_45_goodG2BData = data;\n    goodG2BSink();\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_44.c",
        "function_name": "badSink",
        "code": "static void badSink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_10_good1",
        "code": "static void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_16_goodB2G",
        "code": "static void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    while(1)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n        break;\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_03_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_01_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_03.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_03_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_44_goodG2B",
        "code": "static void goodG2B()\n{\n    int64_t * data;\n    void (*funcPtr) (int64_t *) = goodG2BSink;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_13_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int * data;\n    data = NULL;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_45.c",
        "function_name": "badSink",
        "code": "static void badSink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_45_badData;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_64a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_64a_goodG2B",
        "code": "static void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_64b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_06_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_15_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_44_goodG2BSink",
        "code": "static void goodG2BSink(int * data)\n{\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_41_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_12_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_01_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_05_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_12_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_18_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67_structType myStruct;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_10.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_10_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalTrue)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(globalTrue)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_11_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_44.c",
        "function_name": "badSink",
        "code": "static void badSink(char * data)\n{\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_12.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_12_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_01.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_01_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_08_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63b_goodG2BSink(&data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_05.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_05_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(staticTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_41_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_08.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_08_goodB2G1",
        "code": "static void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_42.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_42_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    data = goodG2BSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_14_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_16_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21.c",
        "function_name": "badSink",
        "code": "static void badSink(int data)\n{\n    if(badStatic)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_13.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_13_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_41.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_41_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_41_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_45_goodG2BData;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_44.c",
        "function_name": "badSink",
        "code": "static void badSink(int * data)\n{\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_44_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    void (*funcPtr) (char *) = goodG2BSink;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_34.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_34_goodG2B",
        "code": "static void goodG2B()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_34_unionType myUnion;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myUnion.unionFirst = data;\n    {\n        twoIntsStruct * data = myUnion.unionSecond;\n        {\n            twoIntsStruct source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(twoIntsStruct));\n            printStructLine(&data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_17.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_17_goodG2B",
        "code": "static void goodG2B()\n{\n    int h;\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_16.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_16_goodG2B",
        "code": "static void goodG2B()\n{\n    int * data;\n    data = NULL;\n    while(1)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n        break;\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67_structType myStruct;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67b_goodG2BSink(myStruct);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_07_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_09.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_09_goodG2B2",
        "code": "static void goodG2B2()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_66a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_66a_goodG2B",
        "code": "static void goodG2B()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_66b_goodG2BSink(dataArray);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_04.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_04_goodG2B1",
        "code": "static void goodG2B1()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_15.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_15_goodG2B1",
        "code": "static void goodG2B1()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_14.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_14_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_07.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_07_goodG2B1",
        "code": "static void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_goodG2BSink",
        "code": "static void goodG2BSink()\n{\n    int data = CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_goodG2BData;\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_44.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_44_goodG2BSink",
        "code": "static void goodG2BSink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_44.c",
        "function_name": "badSink",
        "code": "static void badSink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}",
        "target": 1
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_02.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_02_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE135_54a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE135_54a_goodB2G",
        "code": "static void goodB2G()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_54b_goodB2GSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_18.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_18_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_11.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_11_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(globalReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52a.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52a_goodG2B",
        "code": "static void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52b_goodG2BSink(data);\n}",
        "target": 0
    },
    {
        "filename": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_06.c",
        "function_name": "CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_06_goodG2B2",
        "code": "static void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}",
        "target": 0
    }
]